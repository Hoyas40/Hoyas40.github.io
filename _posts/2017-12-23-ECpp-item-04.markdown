---
layout: post
title:  "EC++ 항목 04 - 객체를 사용하기 전에 반드시 그 객체를 초기화하자"
subtitle:   "Effective cpp item 04"
categories: development
tags: c++
comments: true
---

객체를 사용하기 전에 반드시 그 객체를 초기화하자

## 이것만은 잊지말자 1
> `기본 제공 타입`의 객체는 직접 손으로 초기화하자.

### 규칙을 외울 필요는 없다.
저자는 규칙이 존재하기는 하지만, 너무 복잡하기에 `굳이 외울 필요는 없다`고 한다.  
단지 항상 초기화를 하면 된다.  
참고로 C++11 이후 버전에서 사용 가능한 `auto`는 반드시 초기화를 해줘애 한다.

---
## 이것만은 잊지말자 2
> 생성자에서는 멤버 `초기화 리스트를 즐겨 사용`하자.
> 초기화 리스트의 멤버 순서는 선언된 순서와 똑같이 하자.

### 멤버 초기화 리스트
초기화 리스트는 `대입 생성자를 사용`하기에 `더 효율적`일 가능성이 크다.  
또한, 초기화를 굳이 하지 않을 데이터 멤버도 초기화 리스트에 추가하는 걸 추천한다.
이 것을 rule 로 정해 두어야 멤버 변수가 추가될 때 초기화 리스트에도 추가하는 걸 잊지 않을 수 있다.
```C++
ABEntry::ABEntry()
: theName(),    // 초기화 value 가 없는 멤버 변수들
  theAddress(),
  thePhones()
{}
```

### 멤버 초기화 리스트가 필수인 경우
필수적으로 사용해야 하는 경우는 다음과 같다.
* `상수` 멤버 변수
* `참조자` 멤버 변수

### 반드시 멤버 초기화 리스트를 사용해야 하는가?
그렇지는 않다.  
멤버 변수가 많고, 생성자 함수 또한 다수가 있다면 `별도의 함수`를 사용해서 `코드 중복`을 피해도 된다.


---
## 이것만은 잊지말자 3
> `여러 번역 단위`에 있는 `비지역 정적 객체`들의 `초기화 순서` 문제는 피해서 설계 하자.
> `지역 정적 객체`로 바꾸면 된다.

## 비지역 정적 객체의 초기화 순서는 개별 단위에서 정해진다.
먼저 중요한 사실 하나 투척한다.  
`비지역 정적 객체`의 초기화 순서는 `개별 번역 단위`에서 정해진다.  
따라서, 서로 다른 번역 단위에 위치한 정적 객체의 초기화 순서는 정해질 수 없으며,  
이 순서에 의존하는 코드는 피해야 한다.

`비지역 정적 객체`는 다음과 같다.
1. 전역 객체
1. 네임스페이스 유효 범위에 정의된 객체
1. 클래스의 static 멤버 객체
1. 파일 유효범위의 static 객체

`지역 정적 객체`
1. `함수 내부`에서 선언된 정적 객체


### 해결 방법
바로 간단한 `singleton` 을 사용하는 것이다.
```C++
FileSystem& tfs()
{
    static FileSystem fs;
    return fs;
}
```

하지만 위 singleton은 `다중 스레드`에서 문제가 생길 수도 있다.  
사실 다중 스레드에서 비상수 정적 객체( `비지역 포함` ) 들은 가장 큰 골칫 거리 중 하나이다.  
해결 방법 중 하나는 프로그램 초기 단계에서 모든 singleton의 함수를 호출해 주는 것이다.
